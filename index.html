<!DOCTYPE html>
<html>
	<head>
		<meta content="text/html;charset=utf-8" http-equiv="Content-Type" />
		<link rel="stylesheet" href="node_modules/xterm/css/xterm.css" />
		<script type="text/javascript" src="node_modules/xterm-addon-attach/lib/xterm-addon-attach.js"></script>
		<script type="text/javascript" src="node_modules/xterm-addon-fit/lib/xterm-addon-fit.js"></script>
		<script type="text/javascript" src="node_modules/xterm-addon-search/lib/xterm-addon-search.js"></script>
		<script type="text/javascript" src="node_modules/xterm-addon-web-links/lib/xterm-addon-web-links.js"></script>
		<script type="text/javascript" src="node_modules/xterm/lib/xterm.js"></script>
		<script type="text/javascript" src="xterm.min.js"></script>
		<title>Terminal</title>
		<style type="text/css">
* {
	margin: 0px;
	padding: 0px;
}

body {
	position: absolute;
	display: block;
	width: 100%;
	height: 100%;
	font-family: monospace;
	overflow-x: hidden;
	background-color: black;
}

#terminal {
	position: relative;
	display: block;
	padding: 20px;
	width: 100% - 20px;
	height: fit-content;
}
		</style>
	</head>
	<body>
		<div id="terminal"></div>
		<script type="text/javascript">

class Executable {
	constructor(name) {
		this.name = name;
	}

	exec(linux, args) {
		if (args.length == 2 && args[1] == "--help")
			return this.onHelp(linux);
		let pureArgs = [];
		let options = [];
		for (let i = 0; i < args.length; i++) {
			let arg = args[i];
			if (arg.startsWith("--"))
				options.push(arg.substring(2, arg.length));
			else if (arg.startsWith("-")) {
				for (let c = 1; c < arg.length; c++)
					options.push(arg.charAt(c));
			} else pureArgs.push(arg);
		}
		return this.onExec(linux, options, pureArgs);
	}

	onExec(linux, options, args) {
		if (args.length == 1 && args[0].includes("=")) {
			// set environment variable
			let params = args[0].split("=");
			let key = params[0];
			let value = params[1];
			linux.env[key] = value;
			return 0;
		} else {
			// default output
			this.output(this.name + ": command not found");
			return 127;
		}
	}

	onHelp(linux) {
		this.output("No help available.");
		return 0;
	}

	output(msg, newLine = true) {
		if (newLine)
			msg += "\r\n";
		term.write(msg);
	}

	clear() {
		term.clear();
	}
}

class Help extends Executable {
	constructor() {
		super("help");
	}

	onExec(linux, options, args) {
		if (args.length == 1) {
			this.output("Available commands: ");
			let str = "\t";
			let cmds = linux.executables;
			for (let i = 0; i < cmds.length; i++)
				str += cmds[i].name + " ";
			this.output(str);
			this.output("\nTry 'help + command' for more detailed informations.");
		} else if (args.length == 2)
			getCommandByName(args[1]).onHelp(linux);
		else {
			this.output("Invalid options");
			return 1;
		}
		return 0;
	}
}

class Clear extends Executable {
	constructor() {
		super("clear");
	}

	onExec(linux, options, args) {
		for (let i = 0; i < options.length; i++) {
			this.output("clear: invalid option " + quote(options[i]));
			return 1;
		}
		super.clear();
		return 0;
	}
}

class Cd extends Executable {
	constructor() {
		super("cd");
	}

	onExec(linux, options, args) {
		for (let i = 0; i < options.length; i++) {
			this.output("cd: invalid option " + options[i]);
			return 1;
		}
		if (args.length > 2) {
			this.output("cd: too many arguments");
			return 1;
		} else if (args.length == 1)
			linux.directory = linux.home;
		else {
			let path = absPath(linux.directory, args[1]);
			switch (checkExistence(path)) {
				case "file":
					this.output("cd: " + path + ": Not a directory");
					return 1;
				case "directory":
					linux.directory = path;
					break;
				default:
					this.output("cd: " + path + ": No such file or directory");
					return 1;
			}
		}
		return 0;
	}
}

class Echo extends Executable {
	constructor() {
		super("echo");
	}

	exec(linux, args) {
		let str = "";
		for (let i = 1; i < args.length; i++)
			str += args[i] + " ";
		this.output(str);
		return 0;
	}
}

class Exit extends Executable {
	constructor() {
		super("exit");
	}

	onExec(linux, options, args) {
		for (let i = 0; i < options.length; i++) {
			this.output("Invalid option: " + options[i]);
			return 1;
		}
		linux.term.closed = true;
		linux.term.prompt = () => {};
		this.clear();
		return 0;
	}
}

class Curl extends Executable {
	constructor() {
		super("curl");
	}

	checkUrl(url) {
		try {
			return new URL(url).href;
		} catch(err) {
			return null;
		}
	}

	onExec(linux, options, args) {
		for (let i = 0; i < options.length; i++) {
			this.output("curl: invalid option " + quote(options[i]));
			return 1;
		}
		if (args.length == 1) {
			this.output("curl: no URL specified!");
			return 1;
		}
		for (let i = 1; i < args.length; i++) {
			let url = this.checkUrl(args[i]);
			if (url == null) {
				this.output("curl: invalid URL: " + quote(args[i]));
				return 1;
			}
			let embed = document.createElement("object");
			let body = document.getElementsByTagName("body")[0];
			embed.type = "text/plain";
			embed.width = 800;
			embed.height = 600;
			embed.data = url;
			embed.onload = (e) => {
				let doc = embed.contentDocument;
				if (doc == null)
					doc = embed.contentWindow.document;
				this.output(doc.documentElement.innerHTML);
				body.removeChild(embed);
			};
			body.appendChild(embed);
		}
		return 0;
	}
}

class Mkdir extends Executable {
	constructor() {
		super("mkdir");
	}

	onExec(linux, options, args) {
		if (args.length == 1) {
			this.output("mkdir: missing operand");
			return 1;
		}
		let parent = false;
		let verbose = false;
		for (let i = 0; i < options.length; i++) {
			switch(options[i]) {
				case "p":
				case "parent":
					parent = true;
					break;
				case "v":
				case "verbose":
					verbose = true;
					break;
				default:
					this.output("mkdir: invalid option " + quote(options[i]));
					return 1;
			}
		}
		let code = 0;
		for (let i = 1; i < args.length; i++) {
			let obj = args[i];
			let path = absPath(linux.directory, obj);
			if (checkExistence(path) != "not-found") {
				this.output("mkdir: cannot create directory " + quote(obj) + ": File exists");
				code = 1;
			} else {
				if (parent) {
					// create parent directories
					for (let parent = parentPath(path); parent != "/"; parent = parentPath(parent)) {
						switch (checkExistence(parent)) {
							case "file":
								this.output("mkdir: cannot create directory " + quote(parent) + ": Not a directory");
								code = 1;
								break;
							case "not-found":
								linux.directories.push(parent); // create directory
								if (verbose)
									this.output("mkdir: created directory " + quote(parent));
								break;
						}
					}
					// create target directory
					linux.directories.push(path);
					if (verbose)
						this.output("mkdir: created directory " + quote(obj));
				} else {
					let parent = parentPath(path);
					switch (checkExistence(parent)) {
						case "file":
							this.output("mkdir: cannot create directory " + quote(obj) + ": Not a directory");
							code = 1;
							break;
						case "not-found":
							this.output("mkdir: cannot create directory " + quote(obj) + ": No such file or directory");
							code = 1;
							break;
						default:
							linux.directories.push(path);
							if (verbose)
								this.output("mkdir: created directory " + quote(obj));
							break;
					}
				}
			}
		}
		return code;
	}
}

class Document extends Executable {
	constructor(name) {
		super(name);
	}

	output(str) {
		super.output(str.replace(/(\t|\n)/g, " "));
	}

	onExec(linux, options, args) {
		for (let i = 0; i < options.length; i++) {
			this.output(args[0] + ": invalid option " + quote(options[i]));
			return 1;
		}
		switch (args.length) {
			case 1:
				this.output(document.documentElement.innerHTML);
				break;
			case 2:
				switch (args[1]) {
					case "head":
						this.output(document.getElementsByTagName("head")[0].innerHTML);
						break;
					case "body":
						this.output(document.getElementsByTagName("body")[0].innerHTML);
						break;
					default:
						this.output(args[0] + ": unknown component " + quote(args[1]));
						return 1;
				}
			case 3:
				switch (args[1]) {
					case "set-head":
						document.getElementsByTagName("head")[0].innerHTML = args[2];
						break;
					case "set-body":
						document.getElementsByTagName("body")[0].innerHTML = args[2];
						break;
					case "set":
						document.documentElement.innerHTML = args[2];
						break;
					case "append-head":
						document.getElementsByTagName("head")[0].innerHTML += args[2];
						break;
					case "append-body":
						document.getElementsByTagName("head")[0].innerHTML += args[2];
						break;
					case "append":
						document.documentElement.innerHTML = args[2];
						break;
					default:
						this.output(args[0] + ": invalid operation " + quote(args[1]));
						return 1;
				}
			default:
				this.output(args[0] + ": invalid arguments");
				return 1;
		}
		return 0;
	}
}

let terminal = document.getElementById("terminal");
let term = new Terminal({cursorBlink: "block", rows: 200, cols: Math.floor(terminal.clientWidth / 10)});
let fitAddon = new FitAddon.FitAddon();
let searchAddon = new SearchAddon.SearchAddon();
let webLinksAddon = new WebLinksAddon.WebLinksAddon();
let cursor = 0;
let line = "";
let entries = [];
let linux = {
	files: [],
	directories: [ "/" ],
	directory: "/",
	executables: [
		new Cd(),
		new Clear(),
		new Curl(),
		new Document("document"),
		new Document("doc"),
		new Echo(),
		new Exit(),
		new Help(),
		new Mkdir()
	],
	env: {"HOME": "/"},
	term: term
};

term.loadAddon(fitAddon);
term.loadAddon(searchAddon);
term.loadAddon(webLinksAddon);
term.setOption("theme", {
	background: "#000000",
	foreground: "#ffffff"
});
term.prompt = () => {
	term.write(linux.directory + " $ ");
	line = "";
};
term.open(terminal);

function isAbsolute(path) {
	return path.startsWith("/") &&
		!path.includes("/./") &&
		!path.includes("/../") &&
		!path.endsWith(".") &&
		!path.endsWith("..")
}

function absPath(dir, change) {
	if (isAbsolute(change))
		return change;
	
	if (!dir.startsWith("/"))
		dir = "/" + dir;
	if (!dir.endsWith("/"))
		dir += "/";
	
	return new URL("https://example.com" + dir + change).pathname;
}

function parentPath(path) {
	return absPath(path, "..");
}

function checkExistence(path) {
	for (let i = 0; i < linux.files.length; i++)
		if (path == linux.files[i])
			return "file";
	for (let i = 0; i < linux.directories.length; i++)
		if (path == linux.directories[i])
			return "directory";
	return "not-found";
}

function quote(str) {
	return "\'" + str + "\'";
}

function getEnv(id) {
	let env = linux.env[id];
	if (env == null)
		env = "";
	return env;
}

function parseArgs(cmd) {
	let args = [];
	let escaped = false;
	let quoted = false;
	let envVar = false;
	let str = "";
	for (let i = 0; i < cmd.length; i++) {
		let id = cmd.charCodeAt(i);
		let ch = cmd.charAt(i);
		if (quoted || id > 0x20) {
			if (escaped) {
				str += ch;
				escaped = false;
			} else switch (ch) {
				case "\\":
					escaped = true;
					break;
				case "\"":
				case "\'":
					quoted = !quoted;
					break;
				case "$":
					envVar = true;
					break;
				default:
					str += ch;
			}
		} else {
			if (str.length > 0) {
				if (envVar)
					str = getEnv(str);
				args.push(str);
				str = "";
			} else if (envVar)
				args.push("$");
			escaped = false;
			envVar = false;
		}
	}
	if (str.length > 0) {
		if (envVar)
			str = getEnv(str);
		args.push(str);
	} else if (envVar)
		args.push("$");
	return {
		args: args,
		escaped: escaped,
		quoted: quoted
	};
}

function getCommandByName(name) {
	let cmds = linux.executables;
	for (let i = 0; i < cmds.length; i++)
		if (cmds[i].name == name)
			return cmds[i];
	return new Executable(name);
}

function exec(args) {
	let cmd = args[0];
	if (cmd.includes("/")) {
		switch (checkExistence(cmd)) {
			case "directory":
				term.write(cmd + ": Is a directory\r\n");
				return 126;
			case "file":
				term.write(cmd + ": Permission denied\r\n");
				return 126;
			default:
				term.write(cmd + ": No such file or directory\r\n");
				return 127;
		}
	} else return getCommandByName(args[0]).exec(linux, args);
}

String.prototype.replaceAt = function(i, ch) {
	let append = i - this.length;
	if (append < 0)
		return this.substring(0, i) + ch + this.substring(i + 1);
    else if (append == 0)
		return this + ch;
	else {
		let str = this;
		for (let i = 0; i < append; i++)
			str += "\u0000";
		return str + ch;
	}
}

term.closed = false;
term.prompt();
term.on("key", function(key, ev) {
	if (term.closed)
		return;

	switch(ev.keyCode) {
		case 13: // enter
			term.write("\r\n");
			if (line.length > 0) {
				let args = parseArgs(line);
				if (args.quoted || args.escaped)
					line += "\r\n";
				else {
					entries.push(line);
					linux.env["?"] = exec(args.args);
					term.prompt();
				}
			} else term.prompt();
			cursor = 0;
			break;
		case 8: // backspace
			if (line.length > 0) {
				line = line.slice(0, line.length - 1);
				term.write("\b \b");
				cursor--;
			}
			break;
		case 37: // arrow left
			if (cursor > 0) {
				cursor--;
				term.write(key);
			}
			break;
		case 39: // arrow right
			if (cursor < line.length) {
				cursor++;
				term.write(key);
			}
			break;
		case 38: // arrow up
		case 40: // arrow down
			// not supported by now
			break;
		default:
			line = line.replaceAt(cursor, key);
			term.write(key);
			cursor++;
			break;
	}
});

term.on("paste", function(data) {
	if (term.closed)
		return;

	line += data;
	term.write(data);
	cursor += data.length;
});
		</script>
	</body>
</html>